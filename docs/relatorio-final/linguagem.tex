% !TEX encoding = UTF-8 Unicode

  A linguagem de alto nível criada para a construção deste compilador foi baseada nas linguagens de programção imperativas C e Pascal. Nesta seção iremos explicar informalmente as principais estruturas sintáticas reconhecidas pelo compilador.

  A estrutura básica de um programa em nossa linguagem consiste de seis partes principais:

  \begin{itemize}
    \item Declarações de constantes
    \item Declarações de tipos
    \item Declarações de estruturas
    \item Declarações de variáveis globais
    \item Declarações de funções
    \item Programa principal
  \end{itemize}

  Cada uma dessas partes, com excessão do programa principal, não são obrigatórias e podem ser omitidas. No entanto, elas devem seguir a exata ordem indicada acima.

  \section{Declaração de constantes}

  As constantes do programa são declaradas da seguinte maneira:

\begin{lstlisting}
const nome_da_variavel = valor_da_constante;
\end{lstlisting}

  A constante poder ser um número (inteiro ou ponto flutuante), true, false ou um caracter envolto em apóstrofes.

  \section{Declarações de tipos}

  Os tipos definidos pelo usuário são definidos da seguinte maneira:

\begin{lstlisting}
typedef tipo novo_nome;
\end{lstlisting}

  Os novos tipos só podem ser definidos em cima dos tipos básicos da linguagem (bool, int, float, char) ou tipos já definidos acima dele.

  \section{Declaração de estruturas}

  As estruturas são os agregados heterogêneos da linguagem. Nessa linguagem, uma vez declarada uma estrutura, ela é considerada como um tipo a ser usado no resto do programa. Elas são declaradas da seguinte maneira:

\begin{lstlisting}
struct nome_da_estrutura begin 
  declaracao_variavel1; 
  declaracao_variavel2; 
  ... 
  declaracao_variavelN; 
end struct
\end{lstlisting}

  Uma estrutura deve conter pelo menos uma variável. As declarações de variáveis seguem as mesmas regras que as declarações de variáveis globais.

  \section{Declarações de variáveis globais}

  As declarações de variáveis podem ser de dois tipos, variáveis simples ou agregados homogêneos. As variáveis simples seguem a seguinte estrutura:

\begin{lstlisting}
  tipo indentificador_variavel;
\end{lstlisting}

  Já os agregados homogêneos:

\begin{lstlisting}
tipo indentificador_variavel[inteiro];
\end{lstlisting}

  É possível adicionar quantas vezes forem necessárias o párticula [inteiro], criando assim matrizes e não somente vetores.

  Os tipos das variáveis podem ser: os tipos básicos da linguagem, os tipos definidos pelo programador ou as estruturas definidas anteriormente. As variáveis definidas nesse trecho são compartilhadas com todo resto do programa.

  \section{Definições de funções}

  As funções nessa linguagem são definidas como abaixo:

\begin{lstlisting}
function tipo nome_funcao (tipo param1, tipo byref param2, ... tipo paramN) begin
  %
    Bloco interno
  %
end function
\end{lstlisting}

  Os tipos das funções podem ser do mesmo tipo que os das variáveis além de um tipo a mais, o tipo void. Funções que possuem um tipo diferente do tipo void devem obrigatoriamente possuir um retorno. Funções do tipo void também podem possuir retorno, mas esse retorno deve ser obrigatóriamente vazio.

  A estrutura interna de uma função segue a mesma estrutura que o programa principal, portanto, seus detalhes serão explicados a seguir.

  \section{Programa Principal}

  Primeiramente, o compilador aceita programas compostos por uma sequência de declarações de variáveis e, em seguida, uma sequência de comandos. O escopo do programa inicia-se com a sequência das palavras-chaves program seguida de begin. O programa acaba com as palavras end program.Tanto para as declarações de variáveis quanto para os comandos, o separador é o ponto e vírgula. 

\begin{lstlisting} 
program begin
  %
    Espaco destinado a declaracao de variaveis.
  %
  declaracao_var1; declaracao_var2; ... declaracao_varN;

  %
    Espaco destinado a declaracao de comandos.
  %
  comando1; comando2; ... comandoN; 
end program
\end{lstlisting}
          
  A declaração de variáveis segue o mesmo estilo que o das variáveis globais.

  Os comandos podem ser dividos em seis tipos:
  \begin{itemize}
    \item Comando de atribuição
    \item Comando de chamada de função
    \item Comando condicional
    \item Comando iterativo
    \item Comando de entrada
    \item Comando de saída
    \item Comando de retorno
  \end{itemize}

  \subsection{Comando de Atribuição}
                             
  O comando de atribuição associa o valor de uma expressaão a uma variável, explicitada à esquerda do comando. Note que a variável pode ser uma variável escalar, um ponteiro ou um vetor. 

  A avaliação das expressões segue as convenções usuais, sendo efetuada da esquerda para a direita. As expressões podem ser tanto booleanas quanto aritiméticas.

  No caso das expressões aritiméticas, por definição, as potenciações possuem precedência sobre os produtos e divisões, e estes precedência sobre as somas e subtrações. Note que é possível alterar a prioridade de tais precedências graças ao uso de parênteses. As expressões aritiméticas aceitam números, identificadores de variáveis e o valor de retorno de chamadas de função.

  Analogamente, no caso das expressões booleanas, a operação lógica "e" tem prioridade sobre a operação lógica "ou". As expressões booleanas aceitam tanto booleanos puros (true ou false) quanto o resultado de comparações entre expressões aritiméticas.

  \subsection{Comando de chamada de função}
                             
  Funções podem ser consideradas como sub-programas, que recebem um conjunto de parâmetros e que são chamados pelo programa principal para executar uma dada ação. Há dois tipos de função implementadas via mesma estrutura sintática: rotinas e funções. Rotinas têm tipo void e executam seus comandos sem a necessidade de retornar algo no fim de sua execução. Já as funções são tipadas, como por exemplo int ou char, portanto, necessitam de pelo menos um return dentro de seu bloco principal.

  Tanto as funções quanto as rotinas são chamadas através do nome da função requisitada, seguido dos parâmetros que devem ser passados para sua execução entre parênteses. 

\begin{lstlisting}
nome_funcao(parametro1 , parametro2, ..., parametroN);
\end{lstlisting}

  \subsection{Comando condicional}

  Refere-se à possibilidade de realizar um salto condicional segundo o resultado de uma expressão booleana. 

  Além das operações lógicas de "e" e "ou", as expressões booleanas consideram a possibilidade de realizar comparações lógicas entre partículas comparativas, através dos operadores "==" (igual a) ou "!=" (diferente de). Tais partículas são ou booleanos ou o resultado de uma comparação entre expressões aritiméticas, efetuadas através dos operadores "$>$" (maior que), "$<$" (menor que), "$>$=" (maior ou igual a) e "$<$=" (menor ou igual a).

  Há duas estruturas sintáticas possíveis para o comando condicional: a simples, na qual somente são executados os comandos referente à expressão booleana após a palavra reservada \"if\" for verdadeira, e a composta. Neste último caso, caso a comparação seja verdadeira, o comando que se encontra entre as palavras \"then\" e \"else\" será executado. Caso contrário, o comando após o \"else\" será executado. 

\begin{lstlisting}
if expressao_booleana then
  %
    Bloco interno
  %
else
  %
    Bloco interno
  %
end if
\end{lstlisting}

  O bloco interno dos comando condicionais são equivalentes são aos blocos internos de funções e do programa principal.

  \subsection{Comando Iterativo}

  Este comando testa a expressão booleana após a palavra reservada \"while\" para decidir se irá realizar os comandos que segue a palavra “do”. Esta ação solicitada será executada repetidamente até que a condição de teste não mais seja atendida.           

\begin{lstlisting}
while expressao_booleana do
  %
    Bloco interno
  %
end while
\end{lstlisting}
                             
  \subsection{Comandos de Entrada e Saída}

  Os comandos de entrada e saída promovem, respectivamente, a entrada e saída de dados com relação a um meio externo. O comando de leitura captura dados e preenche o valor de uma variável, especificada após a palavra \"scan\". Já o comando de impressão permite a impressão do resultado de uma expressão.

\begin{lstlisting}
scan variavel;

print expressao;
\end{lstlisting}

\section{Exemplo de programa escrito na linguagem definida}

\lstinputlisting{../1-linguagem/notacoes/program_example}

\section{Descrição da linguagem em BNF}

\lstinputlisting{../1-linguagem/notacoes/BNF.txt}

\section{Descrição da linguagem em Wirth}

\lstinputlisting{../1-linguagem/notacoes/wirth.txt}